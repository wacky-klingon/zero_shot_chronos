
AutoGluon-TimeSeries (AG-TS) includes Chronos family of forecasting models. Chronos models are pretrained on a large collection of real & synthetic time series data, which enables them to make accurate forecasts on new data out of the box.

AG-TS provides a robust and easy way to use Chronos through the familiar TimeSeriesPredictor API. This tutorial describes how to

    Use Chronos models in zero-shot mode to make forecasts without any dataset-specific training
    Fine-tune Chronos models on custom data to improve the accuracy
    Handle covariates & static features by combining Chronos with a tabular regression model

New in v1.2: AutoGluon now features Chronos-Bolt⚡️ — new, more accurate, and up to 250x faster Chronos models.


pip install -q autogluon.timeseries --system
pip uninstall -q torchaudio torchvision torchtext --system 


Zero-shot forecasting

Let's work with a subset of the Australian Electricity Demand dataset to see Chronos-Bolt in action.
First, we load the dataset as a TimeSeriesDataFrame.
from autogluon.timeseries import TimeSeriesDataFrame, TimeSeriesPredictor
data = TimeSeriesDataFrame.from_path(
    "https://autogluon.s3.amazonaws.com/datasets/timeseries/australian_electricity_subset/test.csv"

)
data.head()

Next, we create the TimeSeriesPredictor and select the "bolt_small" presets to use the Chronos-Bolt (Small, 48M) model in zero-shot mode.

prediction_length = 48
train_data, test_data = data.train_test_split(prediction_length)

​predictor = TimeSeriesPredictor(prediction_length=prediction_length).fit(
       train_data, presets="bolt_small",
)
As promised, Chronos does not take any time to fit. The fit call merely serves as a proxy for the TimeSeriesPredictor to do some of its chores under the hood, such as inferring the frequency of time series and saving the predictor's state to disk. 
Let's use the predict method to generate forecasts, and the plot method to visualize them.

predictions = predictor.predict(train_data)
predictor.plot(
    data=data,
    predictions=predictions,
    item_ids=data.item_ids[:2],
    max_history_length=200,
);

Fine-tuning

We have seen above how Chronos models can produce forecasts in zero-shot mode. AutoGluon also makes it easy to fine-tune Chronos models on a specific dataset to maximize the predictive accuracy.

The following snippet specifies two settings for the Chronos-Bolt ️(Small) model: zero-shot and fine-tuned. TimeSeriesPredictor will perform a lightweight fine-tuning of the pretrained model on the provided training data. We add name suffixes to easily identify the zero-shot and fine-tuned versions of the model.

predictor = TimeSeriesPredictor(prediction_length=prediction_length).fit(
    train_data=train_data,
    hyperparameters={
        "Chronos": [
            {"model_path": "bolt_small", "ag_args": {"name_suffix": "ZeroShot"}},
            {"model_path": "bolt_small", "fine_tune": True, "ag_args": {"name_suffix": "FineTuned"}},
        ]
    },
    time_limit=60,  # time limit in seconds
    enable_ensemble=False,
)

Here we used the default fine-tuning configuration for Chronos by only specifying "fine_tune": True. However, AutoGluon makes it easy to change other parameters for fine-tuning such as the number of steps or learning rate.

predictor.fit(
    hyperparameters={"Chronos": {"fine_tune": True, "fine_tune_lr": 1e-4, "fine_tune_steps": 2000}},
)

For the full list of fine-tuning options, see the Chronos documentation in Forecasting Model Zoo.

After fitting, we can evaluate the two model variants on the test data and generate a leaderboard.

predictor.leaderboard(test_data)


Note that all AutoGluon-TimeSeries models report scores in a "higher is better" format, meaning that most forecasting error metrics like WQL are multiplied by -1 when reported.
Incorporating the covariates

Chronos️ is a univariate model, meaning it relies solely on the historical data of the target time series for making predictions. However, in real-world scenarios, additional exogenous information related to the target series (e.g., holidays, promotions) is often available. Leveraging this information when making predictions can improve forecast accuracy.

AG-TS now features covariate regressors that can be combined with univariate models like Chronos-Bolt to incorporate exogenous information. A covariate_regressor in AG-TS is a tabular regression model that is fit on the known covariates and static features to predict the target column at the each time step. The predictions of the covariate regressor are subtracted from the target column, and the univariate model then forecasts the residuals.

data = TimeSeriesDataFrame.from_path(
    "https://autogluon.s3.amazonaws.com/datasets/timeseries/grocery_sales/test.csv",
)
data.head()




We define two configurations for Chronos-Bolt:
    zero-shot configuration that uses only the historical values of unit_sales without considering the covariates;
    a configuration with a CatBoost regression model as the covariate_regressor. Note that we recommend to apply a target_scaler when using a covariate regressor. Target scaler ensures that all time series have comparable scales, often leading to better accuracy.

Like before, we add suffixes to model names to more easily distinguish them in the leaderboard.

predictor = TimeSeriesPredictor(
    prediction_length=prediction_length,
    target="unit_sales",
    known_covariates_names=["scaled_price", "promotion_email", "promotion_homepage"],
).fit(
    train_data,
    hyperparameters={
        "Chronos": [
            # Zero-shot model WITHOUT covariates
            {
                "model_path": "bolt_small",
                "ag_args": {"name_suffix": "ZeroShot"},
            },
            # Chronos-Bolt (Small) combined with CatBoost on covariates
            {
                "model_path": "bolt_small",
                "covariate_regressor": "CAT",
                "target_scaler": "standard",
                "ag_args": {"name_suffix": "WithRegressor"},
            },
        ],
    },
    enable_ensemble=False,
    time_limit=60,
)

Once the predictor has been fit, we can evaluate it on the test dataset and generate the leaderboard. We see that the model that utilizes the covariates produces a more accurate forecast on the test set.

predictor.leaderboard(test_data)

Additional data provided, testing on additional data. Resulting leaderboard will be sorted according to test score (`score_test`).

	model	score_test	score_val	pred_time_test	pred_time_val	fit_time_marginal	fit_order
0	ChronosWithRegressor[bolt_small]	-0.268969	-0.358048	0.881176	0.916053	1.004376	2
1	ChronosZeroShot[bolt_small]	-0.318562	-0.452296	0.859930	0.844927	0.019435	1


Note that the covariates may not always be useful — for some datasets, the zero-shot model may achieve better accuracy. Therefore, it's always important to try out multiple models and select the one that achieves the best accuracy on held-out data. This is done automatically in AutoGluon's "high_quality" and "best_quality" presets.
